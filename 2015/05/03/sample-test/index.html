<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="SofiaC++"><meta name="description"><title>Sample Test&mdash;Advanced C++</title><link href="/advanced-cpp/favicon.png" rel="icon"><link rel="alternate" href="/advanced-cpp/atom.xml" title="config.title" type="application/atom.xml"><link href="/advanced-cpp/bower_components/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"><link href="/advanced-cpp/bower_components/bootstrap/dist/css/bootstrap-theme.min.css" rel="stylesheet"><link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css" rel="stylesheet"><style>body { padding-top: 50px; }</style></head><body><div class="container"><nav role="navigation" class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Advanced C++</a></div><div id="navbar" class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a href="/advanced-cpp/categories/news/">News</a></li><li><a href="/advanced-cpp/categories/slides/">Slides</a></li><li><a href="/advanced-cpp/about/">About</a></li></ul></div></div></nav><div class="page-header"><h1><a href="/advanced-cpp/">Advanced C++</a></h1><p id="site-slogan">Site for the Advanced C++ course at FMI</p></div><div class="row"><div class="col-sm-9"><section id="content"><article class="post"><h2>Sample Test</h2><div class="meta">03 May 2015</div><ol class="test"><li>(1) Кога ще се унищожи променливата а?<pre class="mstretch"><code>if (auto a = answer()) { // 1
} else { // 2
} // 3</code></pre><ul class="choice inline"><li>1</li><li>2</li><li>3</li></ul></li><li>(2) Кога се създава и унищожава член променливата <code>m_Name </code>спрямо създаването на инстанция на Person?<pre class="mstretch"><code>struct Person {
    Person(const char* name)
    // 1
    {
        m_Name = name; // 2
    } // 3
    ~Person()
    // 4
    {
      // 5
    } // 6
};</code></pre><p>Създава:<ul class="choice inline"><li>1</li><li>2</li><li>3</li></ul></p><p>Унищожава:<ul class="choice inline"><li>4</li><li>5</li><li>6</li></ul></p></li><li>(5) Има ли нещо нередно в този код? Ако да - как бихте го
оправили?<pre class="mstretch"><code>struct RenderTarget {
    RenderTarget(int width, int height) {
        auto size = width * height;
        m_BackBuffer = new Color[size];
        m_DepthBuffer = new float[size];
    }
    ~RenderTarget() {
        delete [] m_BackBuffer;
        delete [] m_DepthBuffer;
    }
    Color* m_BackBuffer;
    float* m_DepthBuffer;
};
</code></pre></li><li>(1) Какъв ще е типът на променливата <code>splash</code>?<pre class="mstretch"><code>const Image&amp; Load(const char*);
// ...
auto splash = Load(&quot;splash.png&quot;);</code></pre><ul class="choice inline"><li><code>Image</code></li><li><code>const Image&</code></li><li><code>object</code></li><li>Не се компилира</li></ul></li><li>(1) Как бихме могли да вземем референция към обект използвайки <code>auto</code>?</li><li>(2) Какво представлява sink функцията?<ul class="choice"><li>унищожава аргументите си</li><li>копира аргументите си в променливи, чиито scope
продължава след приключването на функцията</li><li>няма странични ефекти</li></ul></li><li>(1) Изпълнява ли се деструктора на обекти, чиито данни са били
преместени в други инстанции на същия клас?<ul class="choice inline"><li>Да</li><li>Не</li></ul></li><li>(1) Какво прави <code>std::move </code>?<ul class="choice inline"><li>мести данни из паметта</li><li>създава r-value reference от value</li><li>създава value от r-value reference</li></ul></li><li>(8)(16) Трябва да напишете клас <code>Image, </code>който съдържа буфер с байтове. Напишете декларациите на
конструктурите, деструктурите, операторите и член данните,
които класът ще има.</li><li>(2) Как е най-ефективно да предаваме аргументи на sink функция?<ul class="choice inline"><li>по адрес, чрез указател</li><li>по r-value reference</li><li>по константен псевдоним</li><li>по стойност</li></ul></li><li>(8) Напишете клас, който съдържа <code>FILE*</code>и се грижи за затварянето на файла.</li><li>(1) Каква семантика за собственост показва <code>T* pointer</code><ul class="choice inline"><li>Никаква</li><li>за собственост</li><li>за споделена собственост</li></ul></li><li>(1) Каква семантика за собственост показва <code>std::unique_ptr<t> pointer</t></code><ul class="choice inline"><li>Никаква</li><li>за собственост</li><li>за споделена собственост</li></ul></li><li>(1) Каква семантика за собственост показва <code>std::shared_ptr<t> pointer</t></code><ul class="choice inline"><li>Никаква</li><li>за собственост</li><li>за споделена собственост</li></ul></li><li>(2) Защо е по-добре да ползваме <code>std::make_shared&lt;T&gt;(42) </code>вместо <code>std::shared_ptr&lt;T&gt; p(new T(42)) </code></li><li>(4) Кои оператори трябва да предефинира един добър клас за умен
указател?<ul class="choice"><li><code>T& operator*();</code></li><li><code>T* operator->();</code></li><li><code>T& operator*() const;</code></li><li><code>T* operator->() const;</code></li><li><code>operator bool() const;</code></li><li><code>explicit operator bool() const;
</code></li></ul></li><li>(4) Ползвате библиотека за работа с изображения, предоставяща
следния интерфейс:<pre class="mstretch"><code>struct Image {
    /// destroy this image
    virtual void Destroy() = 0;
};
/// creates a new image from file
Image* LoadImage(const char* path);
</code></pre>Как бихте ползвали тази библиотека със <code>std::shared_ptr</code>?</li><li>(2) Какво прави компилаторът, когато види <code>p->method() </code>?<ul class="choice"><li>Дава грешка, ако <code>p </code>не е указател</li><li>Изпълнява <code>operator->() </code>докато не стигне до обикновен указател</li><li>Изпълнява <code>operator->() </code>и очаква резултатът да е обикновен указател</li></ul></li><li>(2) Какво ще направи следния фрагмент?<pre class="mstretch"><code>namespace sql {
    struct Query {
        std::string&amp; statement() const;
    };
    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; output,
            const Query&amp; query) {
    return output &lt;&lt; query.statement();
    }
}

int main () {
    std::Query query;
    std::cout &lt;&lt; query &lt;&lt; std::endl;
    return 0;
}</code></pre><ul class="choice inline"><li>няма да се компилира</li><li>undefined behavior</li><li>ще изведе адреса на query</li><li>ще изведе заявката</li></ul></li><li>(2) Има ли нещо нередно в следния фрагмент. Ако да - поправете го.<pre class="mstretch"><code>template &lt;typename It&gt;
void reverse(It begin, It end)
{
    while (begin != end &amp;&amp; begin != --end)
        std::swap(*begin++, *end);
}
</code></pre></li><li>(1) От какво е съставен интерфейсът на един клас T?<ul class="choice"><li>публичните методи</li><li>публичните член данни</li><li>функциите взимащи T като аргумент</li><li>функциите от namespace-а на T</li></ul></li><li>(1) Какви са предимствата при използване на pImpl спрямо обикновен
клас?<ul class="choice"><li>намалява компилацинните зависимости</li><li>скрива имплементационните детайли</li><li>по-висока производителност при извикване на методи</li></ul></li><li>(1) Какви са предимствата при използване на pImpl спрямо абстрактен
клас?<ul class="choice"><li>намалява компилацинните зависимости</li><li>скрива имплементационните детайли</li><li>по-висока производителност при извикване на методи</li></ul></li><li>(3) Какви условия трябва да изпълняват библиотеката и
клиентското приложение, ако използват STL типове в
интерфейса на библиотеката?<ul class="choice"><li>един и същи компилатор</li><li>една и съща стандартна библотека</li><li>една и съща runtime библиотека</li><li>няма условия</li></ul></li><li>(4) Какви са недостатъците на използването на кодове за грешка?</li><li>(2) Какво се случва ако по време на развиване на стека се появи
ново изключение?<ul class="choice"><li>ще започне да се обработва новото изключение</li><li>undefined behavior</li><li>ще се извика std::terminate</li></ul></li><li>(2) Какво означава the no-throw exception safety guarantee?</li><li>(4) По какъв алгоритъм се избира catch клауза, която да хване
дадено изключение?</li><li>(2) Какво условие трябва да изпълнява дадена lambda функция за
да е съвместима с указател към обикновена фунцкия?<ul class="choice inline"><li>Да няма аргументи</li><li>Да има празен capture</li><li>Няма как lambda да е съвместима с указател към функция</li></ul></li><li>(4) Използвайте scope_exit, така че независимо какво се случи,
транзакцията ще бъде или комитната или отменена<pre class="mstretch"><code>// scope_exit returns an object which executes a funtion
// when the object is destroyed, i.e. the scope exits
template &lt;typename Functor&gt;
magic scope_exit(Functor f);

class Query {
    void execute() {
        _success = false;
        // ... do work
        _success = true;
    }
    void commit_or_rollback() {
        if (_success) {
            commit();
        } else {
            rollback();
        }
    }
    void rollback();
    void commit();
    bool _success;
};</code></pre></li></ol></article><div class="row-fluid"><div class="col-md-12"><hr><ul class="pagination"><li class="disabled"><a href="/advanced-cpp/#" title="Previous articles">&larr; Previous</a></li><li><a href="/advanced-cpp/2015/05/02/templates/" title="Next articles">Next &rarr;</a></li></ul></div></div></section></div><div class="col-sm-3"><nav role="navigation" class="navbar navbar-default"><div class="navbar-header"><div class="navbar-brand">Recent Posts</div></div><div class="clearfix"></div><ul class="nav navbar-stacked"><li><a href="/advanced-cpp/2015/05/03/sample-test/">Sample Test</a></li><li><a href="/advanced-cpp/2015/05/02/templates/">Templates</a></li><li><a href="/advanced-cpp/2015/04/20/test-exam-dates/">Test &amp; Exam dates</a></li><li><a href="/advanced-cpp/2015/04/14/locking-problem/">Locking problem</a></li><li><a href="/advanced-cpp/2015/04/03/functional/">Functional C++</a></li><li><a href="/advanced-cpp/2015/03/27/error-handling/">Error Handling</a></li><li><a href="/advanced-cpp/2015/03/20/namespaces/">Namespaces</a></li><li><a href="/advanced-cpp/2015/03/20/libraries/">Libraries</a></li></ul></nav></div></div><footer id="page-footer"><footer><div class="row-fluid"><div class="col-md-12"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" width="88px" height="31px" src="/advanced-cpp/images/cc-by-sa.png"></a><br><span>Advanced C++</span> by<span> SofiaC++</span> is licensed under a&nbsp;<a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International
License
</a></div></div></footer><script src="/advanced-cpp/bower_components/jquery/dist/jquery.min.js"></script><script src="/advanced-cpp/bower_components/bootstrap/dist/js/bootstrap.min.js"></script></footer></div></body></html>