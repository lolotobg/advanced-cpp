<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="description" content="A course about C++"><meta name="author" content="SofiaCPP"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="stylesheet" href="/advanced-cpp/bower_components/reveal.js/css/reveal.min.css"/><link rel="stylesheet" href="/advanced-cpp/css/advanced_cxx.css"><link rel="stylesheet" href="/advanced-cpp/css/tomorrow.css"><title>Move Semantics</title></head><body><div class="reveal"><div class="slides"><section><h1>Move Semantics</h1></section><section><h2>Contents</h2><ul><li><code>auto</code></li><li>Return Value Optimization</li><li>Move Semantics</li><li>Sink functions</li><li>Perfect forwarding</li></ul></section><section><h2><code>auto</code></h2><p>Used to denote that a variable has automatic storage.</p><p>In C++ all variables have automatic storage by default.</p></section><section><h2><code>auto</code></h2><p></p><p>In C++11 it gets a new meaning - tells the compiler to deduce
the type of the variable. This is called <a href="http://en.wikipedia.org/wiki/Type_inference" target="_blank" rel="external">type
inference</a></p>
<p></p></section><section><pre class="mstretch"><code>int x = 42;
std::string s = &quot;the answer is&quot;;

auto y = 2 * x; // 2 is int, int * int = int, so y is int
auto t = s + &quot;!&quot;; // std::string + &quot;!&quot; is string, so t is string

</code></pre></section><section><h2 id="Benefits_of">Benefits of</h2>
</section><figure class="highlight auto```"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">    ul</div><div class="line">        li.fragment.fade-<span class="keyword">in</span> saves time determing what <span class="keyword">is</span> the correct <span class="keyword">type</span></div><div class="line">        li.fragment.fade-<span class="keyword">in</span> allows to refactor the code by renaming a <span class="keyword">type</span></div><div class="line">        li.fragment.fade-<span class="keyword">in</span> allows to change the <span class="keyword">type</span> <span class="keyword">as</span> long <span class="keyword">as</span> it</div><div class="line">            | behaves <span class="keyword">in</span> the same way</div><div class="line">section</div><div class="line">    :cxx</div><div class="line">        <span class="type">BOOL</span> <span class="literal">result</span> = ::<span class="type">CreateProcess</span>(...);</div><div class="line">        <span class="keyword">if</span> (!<span class="literal">result</span>)</div><div class="line">        {</div><div class="line">            <span class="type">DWORD</span> error = ::<span class="type">GetLastError</span>();</div><div class="line">            std::cout &lt;&lt; <span class="string">"Could not create process "</span> &lt;&lt; error</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">section</div><div class="line">    :cxx</div><div class="line">        // don't care what <span class="keyword">type</span> it <span class="keyword">is</span> <span class="keyword">as</span> long <span class="keyword">as</span> it behaves <span class="keyword">as</span> a <span class="type">bool</span></div><div class="line">        <span class="type">auto</span> <span class="literal">result</span> = ::<span class="type">CreateProcess</span>(...);</div><div class="line">        <span class="keyword">if</span> (!<span class="literal">result</span>)</div><div class="line">        {</div><div class="line">            // don't care what <span class="keyword">type</span> it <span class="keyword">is</span> <span class="keyword">as</span> long <span class="keyword">as</span> it can be logged</div><div class="line">            <span class="type">auto</span> error = ::<span class="type">GetLastError</span>();</div><div class="line">            std::cout &lt;&lt; <span class="string">"Could not create process "</span> &lt;&lt; error</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line"></div><div class="line">    p.fragment.fade-<span class="keyword">in</span> <span class="type">Bonus</span>: I don't get shouted at</div><div class="line"></div><div class="line">section</div><div class="line">    :cxx</div><div class="line">        std::vector&lt;<span class="type">int</span>&gt; v;</div><div class="line">        // ...</div><div class="line">        <span class="type">auto</span> begin = v.cbegin();</div><div class="line">        std::vector&lt;<span class="type">int</span>&gt;::const_interator begin2 = v.cbegin();</div><div class="line"></div><div class="line">section</div><div class="line">    :markdown</div><div class="line">        <span class="comment">##</span></div></pre></td></tr></table></figure><auto></auto><figure class="highlight gotchas"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">        * gets the <span class="literal">result</span> by value</div><div class="line"></div><div class="line">    :cxx</div><div class="line">        struct <span class="type">Course</span> {</div><div class="line">            std::vector&lt;<span class="type">int</span>&gt;& get_students() <span class="keyword">const</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        // ...</div><div class="line"></div><div class="line">        <span class="type">auto</span> students = course.get_students();</div><div class="line">        course.get_students()[<span class="number">0</span>] = <span class="number">24</span>;</div><div class="line">        students[<span class="number">0</span>] = <span class="number">42</span>;</div><div class="line">        std::cout &lt;&lt; course.get_students()[<span class="number">0</span>] &lt;&lt; std::endl;</div><div class="line">        // it <span class="keyword">is</span> still <span class="number">24</span></div><div class="line">        // students <span class="keyword">is</span> actually a copy</div><div class="line"></div><div class="line">section</div><div class="line">    :cxx</div><div class="line">        <span class="type">auto</span>& students = course.get_students();</div><div class="line">        course.get_students()[<span class="number">0</span>] = <span class="number">24</span>;</div><div class="line">        students[<span class="number">0</span>] = <span class="number">42</span>;</div><div class="line">        std::cout &lt;&lt; course.get_students()[<span class="number">0</span>] &lt;&lt; std::endl;</div><div class="line">        // it <span class="keyword">is</span> <span class="number">42</span></div><div class="line"></div><div class="line">    :markdown</div><div class="line">        <span class="type">The</span> difference <span class="keyword">is</span> only the **&** after <span class="type">auto</span></div><div class="line"></div><div class="line">section</div><div class="line">    p <span class="type">Taking</span> a <span class="keyword">const</span> reference <span class="keyword">with</span> <span class="type">auto</span></div><div class="line">    :cxx</div><div class="line">        <span class="keyword">const</span> <span class="type">auto</span>& students = course.get_students();</div><div class="line"></div><div class="line">section</div><div class="line">    h2 <span class="type">Return</span> <span class="type">Value</span> <span class="type">Optimization</span></div><div class="line">    p.fragment.fade-<span class="keyword">in</span> <span class="type">RVO</span></div><div class="line"></div><div class="line">section</div><div class="line">    h2 <span class="type">Values</span> returned <span class="keyword">from</span> functions are copied <span class="keyword">in</span> the local variables</div><div class="line"></div><div class="line">section</div><div class="line">    :cxx</div><div class="line">        std::vector&lt;<span class="type">int</span>&gt; get_random_ints(<span class="type">int</span> count);</div><div class="line">        // ...</div><div class="line">        <span class="type">auto</span> numbers = get_random_ints(<span class="number">1000</span>);</div><div class="line"></div><div class="line">section</div><div class="line">    p <span class="type">You</span> can get advice to <span class="keyword">not</span> <span class="keyword">return</span> such expensive to copy things by</div><div class="line">    | value</div><div class="line"></div><div class="line">    :cxx</div><div class="line">        <span class="type">void</span> get_random_ints(<span class="type">int</span> count, std::vector&lt;<span class="type">int</span>&gt;& numbers);</div><div class="line">        // ...</div><div class="line">        std::vector&lt;<span class="type">int</span>&gt; numbers;</div><div class="line">        get_random_ints(<span class="number">1000</span>, numbers);</div><div class="line"></div><div class="line">    ul.fragment.fade-<span class="keyword">in</span></div><div class="line">        li more code</div><div class="line"></div><div class="line">section</div><div class="line">    h2 <span class="type">Optimizations</span></div><div class="line">    p <span class="type">Compilers</span> are allowed to make <span class="type">any</span> optimization <span class="keyword">as</span> long <span class="keyword">as</span> the</div><div class="line">        | program behaves <span class="keyword">in</span> the same way <span class="keyword">as</span> <span class="keyword">if</span> there are no optimizations</div><div class="line"></div><div class="line">section</div><div class="line">    h2 <span class="type">RVO</span></div><div class="line">    p C++ allows compilers to implement <span class="type">RVO</span> even breaking this rule</div><div class="line"></div><div class="line">section</div><div class="line">    h2 <span class="type">How</span> <span class="keyword">is</span> <span class="type">RVO</span> implemented by compilers :cxx std::vector&lt;<span class="type">int</span>&gt; get_random_ints(<span class="type">int</span> count);</div><div class="line">        // ...</div><div class="line">        <span class="type">auto</span> numbers = get_random_ints(<span class="number">1000</span>);</div><div class="line"></div><div class="line">    p <span class="type">Gets</span> compiled <span class="keyword">as</span></div><div class="line">        :cxx</div><div class="line">            <span class="type">void</span> get_random_ints(<span class="type">int</span> count, std::vector&lt;<span class="type">int</span>&gt;& numbers);</div><div class="line">            // ...</div><div class="line">            std::vector&lt;<span class="type">int</span>&gt; numbers;</div><div class="line">            get_random_ints(<span class="number">1000</span>, numbers);</div><div class="line"></div><div class="line">section</div><div class="line">    h3 <span class="type">RVO</span> doesn't always work</div><div class="line">    :cxx</div><div class="line">        std::vector&lt;<span class="type">int</span>&gt; get_numbers() {</div><div class="line">            std::vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;</div><div class="line">            // ...</div><div class="line">            <span class="keyword">return</span> (rand() % <span class="number">2</span>)? <span class="literal">result</span> : std::vector&lt;<span class="type">int</span>&gt;();</div><div class="line">        }</div><div class="line"></div><div class="line">section</div><div class="line">    h2 <span class="type">Move</span></div><div class="line">    p.fragment.fade-<span class="keyword">in</span>.</div><div class="line"></div><div class="line">        <span class="type">Instead</span> <span class="keyword">of</span> copying values move them directly into their new</div><div class="line">        variables</div><div class="line"></div><div class="line">section</div><div class="line">    :markdown</div><div class="line">        <span class="comment">## Move</span></div><div class="line"></div><div class="line">        <span class="type">In</span> C++ it <span class="keyword">is</span> easy to create unneccessary copies <span class="keyword">of</span> <span class="keyword">object</span>,</div><div class="line">        hurting performance.</div><div class="line"></div><div class="line">section</div><div class="line">    :cxx</div><div class="line">        std::<span class="type">string</span> s = <span class="string">"Hello"</span>;</div><div class="line">        std::<span class="type">string</span> t = <span class="string">"World"</span>;</div><div class="line">        std::<span class="type">string</span> m = s + t;</div><div class="line"></div><div class="line">    p.fragment.fade-<span class="keyword">in</span></div><div class="line">        :markdown</div><div class="line"></div><div class="line">            *</div></pre></td></tr></table></figure><s></s><figure class="highlight *"><figcaption><span>is concatenated with *```t```* in a temporary string</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">which <span class="keyword">is</span> <span class="keyword">then</span> copied <span class="keyword">into</span> *</div></pre></td></tr></table></figure><m></m><figure class="highlight *"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">            *assuming that the compiler will not <span class="operator"><span class="keyword">optimize</span> the code*</span></div><div class="line"></div><div class="line"><span class="keyword">section</span></div><div class="line">    :markdown</div><div class="line">        ## *lvalues* <span class="keyword">and</span> *rvalues*</div><div class="line"></div><div class="line">        * comes <span class="keyword">from</span> C</div><div class="line">        * *lvalues* <span class="keyword">are</span> <span class="keyword">on</span> the <span class="keyword">left</span> side <span class="keyword">of</span></div></pre></td></tr></table></figure><operator>=</operator><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">*</span> <span class="keyword">*</span>rvalues<span class="keyword">*</span> are on the right side of</div></pre></td></tr></table></figure><operator>=</operator><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">section</div><div class="line">    :markdown</div><div class="line">        <span class="comment">## *lvalues* and *rvalues*</span></div><div class="line"></div><div class="line">        * In C++</div><div class="line">        * *lvalues* are variables - names of the values, storage <span class="keyword">for</span> the</div><div class="line">            value</div><div class="line">        * *rvalues* are values of expressions</div><div class="line"></div><div class="line">section</div><div class="line">    :markdown</div><div class="line">        <span class="comment">## Rule of thumb</span></div><div class="line"></div><div class="line">        * `T&&` can be both - lvalue and rvalue</div><div class="line">        * If it has has a *name* it is a *lvalue*</div><div class="line">section</div><div class="line">    :cxx</div><div class="line">        Derived(Derived&& other) </div><div class="line">          : Base(other) // wrong: other is an lvalue --&gt; copies the Base part</div><div class="line">        {</div><div class="line">            // <span class="keyword">...</span></div><div class="line">        }</div><div class="line">section</div><div class="line">    :cxx</div><div class="line">        Derived(Derived&& other) </div><div class="line">          : Base(std::move(other)) // :)</div><div class="line">        {</div><div class="line">            // <span class="keyword">...</span></div><div class="line">        }</div><div class="line"></div><div class="line">section</div><div class="line">    ul</div><div class="line">        li.fragment.fade-<span class="keyword">in</span> lvalue reference</div><div class="line">            code <span class="literal">T</span>&</div><div class="line">        li.fragment.fade-<span class="keyword">in</span> rvalue reference</div><div class="line">            code <span class="literal">T</span>&&</div><div class="line"></div><div class="line"></div><div class="line">section</div><div class="line">    :markdown</div><div class="line">        <span class="comment">##</span></div></pre></td></tr></table></figure><const>T&</const><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">        <span class="type">Can</span> reference everything - values stored <span class="keyword">in</span> variables, <span class="literal">result</span></div><div class="line">        values <span class="keyword">of</span> expressions.</div><div class="line"></div><div class="line">section</div><div class="line">    :markdown</div><div class="line">        <span class="comment">##</span></div></pre></td></tr></table></figure><const>T&&</const><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">        Can reference only result values of expressions</div><div class="line"></div><div class="line">section</div><div class="line">    :cxx</div><div class="line">        <span class="keyword">void</span> function(<span class="keyword">const</span> std::<span class="built_in">string</span>& lvalue);  <span class="comment">// lvalue overload</span></div><div class="line">        <span class="keyword">void</span> function(<span class="keyword">const</span> std::<span class="built_in">string</span>&& rvalue); <span class="comment">// rvalue overload</span></div><div class="line"></div><div class="line">    Given both declarations the compiler choose which overload to call,</div><div class="line">    based on the type of the <span class="built_in">string</span> value function is called.</div><div class="line"></div><div class="line">section</div><div class="line">    :cxx</div><div class="line">        std::<span class="built_in">string</span> s = <span class="string">"Hello World"</span>;</div><div class="line">        function(s); <span class="comment">// lvalue overload</span></div><div class="line"></div><div class="line">        function(<span class="string">"Hello World"</span>); <span class="comment">// rvalue overload</span></div><div class="line">        <span class="comment">// the const char* is converted in temporary string, which can be</span></div><div class="line">        <span class="comment">// rvalue</span></div><div class="line"></div><div class="line">section</div><div class="line">    :cxx</div><div class="line">        <span class="keyword">class</span> String {</div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            String(<span class="keyword">const</span> <span class="keyword">char</span>* s)</div><div class="line">                : m_Length(std::<span class="built_in">strlen</span>(s))</div><div class="line">                , m_Buffer(<span class="keyword">new</span> <span class="keyword">char</span>[m_Length])</div><div class="line">            {</div><div class="line">                std::<span class="built_in">memcpy</span>(m_Buffer, s, m_Length);</div><div class="line">            }</div><div class="line"></div><div class="line">            ~String() {</div><div class="line">                <span class="keyword">delete</span> [] m_Buffer;</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keyword">private</span>:</div><div class="line">            size_t m_Length;</div><div class="line">            <span class="keyword">char</span>* m_Buffer;</div><div class="line">        };</div><div class="line">section</div><div class="line">    h3 String representation</div><div class="line">    img(width=<span class="string">"100%"</span> src=<span class="string">"04_move/storage.svg"</span>)</div><div class="line"></div><div class="line">section</div><div class="line">    h3 Copy constructor</div><div class="line">    :cxx</div><div class="line">        String(<span class="keyword">const</span> String& o)</div><div class="line">            : m_Length(o.m_Length)</div><div class="line">            , m_Buffer(<span class="keyword">new</span> <span class="keyword">char</span>[m_Length])</div><div class="line">        {</div><div class="line">            std::<span class="built_in">memcpy</span>(m_Buffer, o.m_Buffer, m_Length);</div><div class="line">        }</div><div class="line">    p Create a copy of the other <span class="built_in">string</span></div><div class="line"></div><div class="line">section</div><div class="line">    h3 Copy construction</div><div class="line">    img(width=<span class="string">"100%"</span> src=<span class="string">"04_move/copy.svg"</span>)</div><div class="line"></div><div class="line">section</div><div class="line">    h3 Move constructor</div><div class="line">    :cxx</div><div class="line">        <span class="keyword">class</span> String {</div><div class="line">            <span class="comment">// ...</span></div><div class="line">            String(String&& o)</div><div class="line">                : m_Buffer(o.m_Buffer);</div><div class="line">                , m_Length(o.m_Length)</div><div class="line">            {</div><div class="line">                o.m_Buffer = <span class="keyword">nullptr</span>;</div><div class="line">                o.m_Length = <span class="number">0</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">        String(<span class="keyword">const</span> String&& o)</div><div class="line">    p Moves the value of the other <span class="built_in">string</span> into <span class="keyword">this</span> object</div><div class="line"></div><div class="line">section</div><div class="line">    h3 Move construction</div><div class="line">    img(width=<span class="string">"100%"</span> src=<span class="string">"04_move/move.svg"</span>)</div><div class="line"></div><div class="line">section</div><div class="line">    :cxx</div><div class="line">        String s(<span class="string">"Hello"</span>);</div><div class="line">        String t(<span class="string">"World"</span>);</div><div class="line"></div><div class="line">        String s2 = s; <span class="comment">// copy</span></div><div class="line">        String t2 = s + t; <span class="comment">// move</span></div><div class="line"></div><div class="line">section</div><div class="line">    :markdown</div><div class="line">        <span class="preprocessor">##</span></div></pre></td></tr></table></figure><std::move>```<tells>the compiler to create an rvalue reference for a lvalue.</tells><allows>us to move ordinary values stored in variables.</allows></std::move><section><pre class="mstretch"><code>template &lt;typename T&gt;
T&amp;&amp; std::move(T&amp; lvalue);</code></pre></section><section><pre class="mstretch"><code>String s(&quot;Hello&quot;);
String t = std::move(s); // move s into t

// !!! Undefined behavior !!!
std::cout &lt;&lt; s &lt;&lt; std::endl;
// We have moved s into t, it's value is unknown
</code></pre></section><section><h2>Asignment operator</h2><pre class="mstretch"><code>class String {
    // ..
    
    String&amp; operator= (const String&amp; rhs) {
        if (this != &amp;rhs) {
            delete [] m_Buffer;
            m_Length = o.m_Length;
            m_Buffer = new char[rhs.m_Length];
            std::memcpy(m_Buffer, rhs.m_Buffer, m_Length);
        }
        return *this;
    }</code></pre></section><section><h2>Asignment operator</h2><p>before</p><img width="100%" src="04_move/assign.svg"></section><section><h2>Asignment operator</h2><p>after</p><img width="100%" src="04_move/copy_assign.svg"></section><section><h2>Move asignment</h2><pre class="mstretch"><code>class String {
    // ..
    // move assignment
    String&amp; operator= (String&amp;&amp; rhs) {
        if (this != &amp;rhs) {
            delete [] m_Buffer;
            m_Length = o.m_Length;
            m_Buffer = rhs.m_Buffer;
            rhs.m_Buffer = nullptr;
        }
        return *this;
    }
};
</code></pre></section><section><h2>Move Assignment</h2><p>before</p><img width="100%" src="04_move/assign.svg"></section><section><h2>Move Asignment</h2><p>after</p><img width="100%" src="04_move/move_assign_1.svg"></section><section><h2>Copy or Move?</h2><pre class="mstretch"><code>String s = &quot;Hello&quot;;
String t = &quot;World&quot;;

String m = s + t; // 1
m = t + s; // 2

m = t; // 3
m = std::move(s); // 4</code></pre><ol><li class="fragment fade-in">move</li><li class="fragment fade-in">move</li><li class="fragment fade-in">copy</li><li class="fragment fade-in">move</li></ol></section><section><h2>Move asignment - alternative implementation</h2><pre class="mstretch"><code>class String {
    // ..
    // move assignment
    String&amp; operator= (String&amp;&amp; rhs) {
        std::swap(m_Buffer, rhs.m_Buffer);
        std::swap(m_Length, rhs.m_Length);
        return *this;
    }
};
</code></pre></section><section><h2>Move Assignment - alternative implementation</h2><p>before</p><img width="100%" src="04_move/assign.svg"></section><section><h2>Move Asignment - alternative implementation</h2><p>after</p><img width="100%" src="04_move/move_assign_2_1.svg"></section><section><h2>Move Asignment - alternative implementation</h2><p>in the end</p><img width="100%" src="04_move/move_assign_2.svg"></section><section><strong>Although the value of an object may be moved, the object still is
going to be destoyed (its constructor has been run)
</strong></section><section><h2>Always leave moved object in a consistent state</h2><p>So that their destructor will run correctly.</p></section><section><section><h2>Perfect forwarding</h2></section><section><pre class="mstretch"><code>template &lt;typename T, typename Arg1&gt;
T factory(/*const*/ Arg1 /*&amp;*/ arg1)
{
    return T(arg1);
}</code></pre><ul>
<li><code>Arg1 arg1</code></li>
<li><code>Arg1&amp; arg1</code></li>
<li><code>const Arg1&amp; arg1</code></li>
</ul>
</section><section><h3 id="Arg1_arg1"><code>Arg1 arg1</code></h3>
<ul>
<li>will be <em>wrong</em> if T stores a reference/pointer to the value</li>
<li>extra copying</li>
</ul>
</section><section><h3 id="Arg1&amp;_arg1"><code>Arg1&amp; arg1</code></h3>
<ul>
<li>will be <em>OK</em> if T stores a reference/pointer to the value</li>
<li><em>no</em> extra copying</li>
<li>will <em>NOT</em> work for const references and temporaries</li>
</ul>
</section><section><h3 id="const_Arg1&amp;_arg1"><code>const Arg1&amp; arg1</code></h3>
<ul>
<li>will be <em>OK</em> if T stores a <strong><code>const</code></strong> reference/pointer to the
value</li>
<li><em>no</em> extra copying</li>
<li>will <em>NOT</em> work for const references and temporaries</li>
</ul>
</section><section><h3>And now what?</h3></section><section><h3>Overloading</h3><pre class="mstretch"><code>template &lt;typename T, typename Arg1&gt;
T factory(Arg1&amp; arg1);

template &lt;typename T, typename Arg1&gt;
T factory(const Arg1&amp; arg1);

// How about
template &lt;typename T, typename Arg1, typename Arg2&gt;
T factory(const Arg1&amp; arg1, const Arg2&amp; arg2);</code></pre></section><section><h3 id="&amp;&amp;"><code>&amp;&amp;</code></h3>
<ul>
<li><code>T&amp; + &amp;</code>   --&gt; <code>T&amp;</code></li>
<li><code>T&amp; + &amp;&amp;</code>  --&gt; <code>T&amp;</code></li>
<li><code>T&amp;&amp; + &amp;</code>  --&gt; <code>T&amp;</code></li>
<li><code>T&amp;&amp; + &amp;&amp;</code> --&gt; <code>T&amp;&amp;</code></li>
</ul>
</section><section><h3>Perfect forwading</h3><pre class="mstretch"><code>template &lt;typename T, typename Arg1&gt;
T factory(Arg1&amp;&amp; arg1)
{
    return T(std::forward&lt;Arg1&gt;(arg1));
}
</code></pre></section><section><h3 id="std::forward"><code>std::forward</code></h3>
<pre class="mstretch"><code>template&lt;class S&gt;
S&amp;&amp; forward(typename remove_reference&lt;S&gt;::type&amp; a) noexcept
{
    return static_cast&lt;S&amp;&amp;&gt;(a);
}</code></pre></section></section><section><p><a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank" rel="external">http://thbecker.net/articles/rvalue_references/section_01.html</a></p>
</section></div></div><script src="/advanced-cpp/bower_components/reveal.js/lib/js/head.min.js"></script><script src="/advanced-cpp/bower_components/reveal.js/js/reveal.min.js"></script><script src="/advanced-cpp/bower_components/reveal.js/plugin/highlight/highlight.js"></script><script src="/advanced-cpp/bower_components/jquery/dist/jquery.min.js"></script><script src="/advanced-cpp/slides.js"></script></body></html>