<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="SofiaC++"><meta name="description"><title>&mdash;Advanced C++</title><link href="/advanced-cpp/favicon.png" rel="icon"><link rel="alternate" href="/advanced-cpp/atom.xml" title="config.title" type="application/atom.xml"><link href="/advanced-cpp/bower_components/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"><link href="/advanced-cpp/bower_components/bootstrap/dist/css/bootstrap-theme.min.css" rel="stylesheet"><style>body { padding-top: 50px; }</style></head><body><div class="container"><nav role="navigation" class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Advanced C++</a></div><div id="navbar" class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a href="/advanced-cpp/categories/news/">News</a></li><li><a href="/advanced-cpp/categories/slides/">Slides</a></li><li><a href="/advanced-cpp/about/">About</a></li></ul></div></div></nav><div class="page-header"><h2></h2></div><div class="row"><div class="col-sm-9"><section id="content"><article><p>+++ slide</p>
<h1 id="Functional_C++">Functional <code>C++</code></h1>
<p>+++<br>+++ slide</p>
<p>section</p>
<h2 id="Contents">Contents</h2>
<ul>
<li><code>C++</code> 98</li>
<li><em>lambda</em> functions</li>
<li><code>std::function</code></li>
<li><em>signals</em> and <em>slots</em></li>
</ul>
<p>+++<br>+++ slide</p>
<h2 id="C-style"><code>C</code>-style</h2>
<pre><code>void qsort(void* pointer, size_t count, size_t size,
    int <span class="comment">(*comparator) (const void*, const void*)</span>);
</code></pre><p>+++<br>+++ slide</p>
<p>::: snippet 10_functional/qsort.cxx comparator sort<br>:::</p>
<p>+++<br>+++ slide</p>
<ul>
<li>does not work for <em>non-POD</em></li>
<li>needs a new function</li>
<li><code>C++&#39;98</code> does not allow defining functions inside functions</li>
<li>the functions does not allow to store state, unless it is global</li>
<li>the function has to always be called indirectly through pointer<ul>
<li>and will get called O(N<em>log</em>N) times for sorting <em>N</em> numbers</li>
</ul>
</li>
</ul>
<p>+++<br>+++ slide</p>
<h2 id="C++‘98_style"><code>C++</code>‘98 style</h2>
<pre><code><span class="keyword">void</span> sort(T <span class="keyword">begin</span>, T <span class="keyword">end</span>, C comparator);
</code></pre><p>+++<br>+++ slide</p>
<p>::: snippet  10_functional/sort98.cxx  comparator sort<br>:::</p>
<p>+++<br>+++ slide</p>
<ul>
<li>works for everything that has <code>operator &lt;</code></li>
<li>needs a new function or functor</li>
<li>you can store state</li>
<li>the function can be inlined and optimized</li>
</ul>
<p>+++<br>+++ slide</p>
<pre><code><span class="keyword">template</span> &lt;typename T, typename P&gt;
T partition(T begin, T <span class="keyword">end</span>, P unary_predicate);

// partitions a <span class="type">range</span> so that all X <span class="keyword">for</span> which predicate(X) <span class="keyword">is</span> <span class="literal">true</span>
// precede all Y <span class="keyword">for</span> which predicate(Y) <span class="keyword">is</span> <span class="literal">false</span>
</code></pre><p>+++<br>+++ slide</p>
<p>::: snippet 10_functional/partition.cxx less-than</p>
<p>+++<br>+++ slide</p>
<p>::: snippet 10_functional/partition.cxx partition<br>:::</p>
<p>+++<br>+++ slide</p>
<ul>
<li>it is quite a lot of code</li>
<li><code>struct</code> can be defined inside a function<ul>
<li>but such <code>struct</code>s can not be used for instantiating templates<ul>
<li>the standard and <code>g++</code> say so</li>
<li>Visual Studio does not</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>+++<br>+++ slide</p>
<h2 id="C++11_style"><code>C++</code>11 style</h2>
<p>+++<br>+++ slide</p>
<h1 id="lambda">lambda</h1>
<p>+++<br>+++ slide</p>
<h1 id="lambda-1">lambda</h1>
<p>Anonymous functions that can be defined inside functions and can access<br>variables defined outside the anonymous functions.</p>
<p>+++<br>+++ slide</p>
<h3 id="lambda_expressions"><em>lambda</em> expressions</h3>
<pre><code>[<span class="link_label">capture</span>](<span class="link_url">parameters</span>) -&gt; return<span class="emphasis">_type { function_</span>body }
</code></pre><p>+++<br>+++ slide</p>
<pre><code><span class="symbol">std:</span><span class="symbol">:vector&lt;int&gt;</span> v;
<span class="symbol">std:</span><span class="symbol">:partition</span>(v.<span class="keyword">begin</span>(), v.<span class="keyword">end</span>(), [](int x) {
    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>;
});
<span class="symbol">std:</span><span class="symbol">:for_each</span>(v.<span class="keyword">begin</span>(), v.<span class="keyword">end</span>(), [&amp;](int x) {
    <span class="symbol">std:</span><span class="symbol">:cout</span> &lt;&lt; x &lt;&lt; <span class="symbol">std:</span><span class="symbol">:endl</span>;
});
</code></pre><p>+++<br>+++ slide</p>
<h3 id="lambda_captures"><em>lambda</em> captures</h3>
<ul>
<li><code>[]</code> - no variables are captured</li>
<li><code>[x]</code> - x is captured by value</li>
<li><code>[&amp;x]</code> - any external variable is implicitly captured by ref</li>
<li><code>[&amp;]</code> - any external variable is implicitly captured by ref</li>
<li><code>[=]</code> - any external variable is implicitly captured by value</li>
<li><code>[x, &amp;y]</code> - x is captured by value, y - by reference</li>
</ul>
<p>+++<br>+++ slide</p>
<h3 id="Captures">Captures</h3>
<ul>
<li>pointers to <em>lambda</em> functions without captured variables are the same as<br>pointer to non-member functions</li>
<li><code>this</code> can be captured only by value and only inside methods</li>
</ul>
<p>+++<br>+++ slide</p>
<h2 id="Implementation_of_lambda_functions">Implementation of <em>lambda</em> functions</h2>
<p>Most compilers generate a <code>struct</code> with a special name and <code>operator()</code></p>
<ul>
<li>no captures - might generate a non-member function</li>
<li>captures - the captured variables are members of the <code>struct</code></li>
</ul>
<p>+++<br>=== topic</p>
<p>+++ slide</p>
<h2 id="The_future_for_lambda_functions">The future for lambda functions</h2>
<p>+++<br>+++ slide</p>
<h3 id="Generic_lambdas">Generic lambdas</h3>
<pre><code>auto dbl = [](auto x) { <span class="keyword">return</span> x + x; };

<span class="symbol">std:</span><span class="symbol">:vector&lt;int&gt;</span> vi;
<span class="symbol">std:</span><span class="symbol">:transform</span>(vi.<span class="keyword">begin</span>(), vi.<span class="keyword">end</span>(), vi.<span class="keyword">begin</span>(), dbl);

<span class="symbol">std:</span><span class="symbol">:vector&lt;std</span><span class="symbol">:</span><span class="symbol">:string&gt;</span> vs;
<span class="symbol">std:</span><span class="symbol">:transform</span>(vs.<span class="keyword">begin</span>(), vs.<span class="keyword">end</span>(), vs.<span class="keyword">begin</span>(), dbl);
</code></pre><p>+++<br>+++ slide</p>
<h3 id="Initializers">Initializers</h3>
<pre><code>std::vector<span class="xml"><span class="tag">&lt;<span class="title">int</span>&gt;</span></span> vi;
std::tranform(vi.begin(), vi.end(), vi.begin(),
[<span class="link_label">value = 42</span>](<span class="link_url">auto x</span>) {
<span class="code">    return x + value;</span>
});
</code></pre><p>+++<br>+++ slide</p>
<h3 id="Capture_by_move">Capture by <em>move</em></h3>
<pre><code>auto ptr = <span class="symbol">std:</span><span class="symbol">:make_unique&lt;int&gt;</span>(<span class="number">42</span>);
<span class="symbol">std:</span><span class="symbol">:vector&lt;int&gt;</span> vi;
<span class="symbol">std:</span><span class="symbol">:tranform</span>(vi.<span class="keyword">begin</span>(), vi.<span class="keyword">end</span>(), vi.<span class="keyword">begin</span>(),
    [ptr = <span class="symbol">std:</span><span class="symbol">:move</span>(ptr)](auto x) {
        <span class="keyword">return</span> x + *ptr;
});
</code></pre><h1 id="+++">+++</h1>
<p>=== topic<br>+++ slide</p>
<h2 id="Functions_as_first_class_citizen">Functions as first class citizen</h2>
<p>+++<br>+++ slide</p>
<pre><code><span class="symbol">std:</span><span class="symbol">:vector&lt;int&gt;</span> lengths;
<span class="symbol">std:</span><span class="symbol">:vector&lt;string&gt;</span> strings;

lengths.resize(strings.size());
<span class="symbol">std:</span><span class="symbol">:transform</span>(strings.<span class="keyword">begin</span>(), strings.<span class="keyword">end</span>(), lengths.<span class="keyword">begin</span>(),
    <span class="regexp">//</span> ???
);
</code></pre><p>+++<br>+++ slide</p>
<pre><code>std::transform(strings.<span class="keyword">begin</span>(), strings.<span class="keyword">end</span>(), lengths.<span class="keyword">begin</span>(),
    std::<span class="keyword">string</span>::length <span class="comment">// ???</span>
);
<span class="comment">// No</span>
</code></pre><p>+++<br>+++ slide</p>
<h3 id="Functions_in_C++">Functions in <code>C++</code></h3>
<ul>
<li><em>free</em> functions</li>
<li><p><em>methods</em></p>
<p>  free_function(a, 42);</p>
<p>  object.method(42);</p>
</li>
</ul>
<p>+++<br>+++ slide</p>
<pre><code>size_t <span class="function">get_length</span>(const std<span class="value">::string&amp; s) {
    return s.<span class="function">length</span>();</span>
}

std<span class="value">::<span class="function">transform</span>(strings.<span class="function">begin</span>(), strings.<span class="function">end</span>(), lengths.<span class="function">begin</span>(),
    get_length;</span>
);
</code></pre><p>+++<br>+++ slide</p>
<h3 id="C++98"><code>C++</code>98</h3>
<pre><code><span class="symbol">std:</span><span class="symbol">:transform</span>(strings.<span class="keyword">begin</span>(), strings.<span class="keyword">end</span>(), lengths.<span class="keyword">begin</span>(),
    <span class="symbol">std:</span><span class="symbol">:mem_fun_ref</span>(&amp;<span class="symbol">std:</span><span class="symbol">:string</span><span class="symbol">:</span><span class="symbol">:length</span>);
);
</code></pre><p>+++<br>+++ slide</p>
<h3 id="std::mem_fun"><code>std::mem_fun</code></h3>
<ul>
<li>works only for methods without arguments or a single argument</li>
<li>the object has to be supplied via a pointer</li>
<li><code>std::mem_fun_ref</code> works with a reference</li>
<li><strong>DEPRECATED</strong></li>
</ul>
<p>+++<br>+++ slide</p>
<h3 id="Currying">Currying</h3>
<p>+++<br>+++ slide</p>
<h3 id="std::bind1st_and_std::bind2nd"><code>std::bind1st</code> and <code>std::bind2nd</code></h3>
<p>Bind the first (second) argument of a function to a fixed value and return a<br>function with one argument less.</p>
<p><strong>DEPRECATED</strong></p>
<p>+++<br>+++ slide</p>
<pre><code><span class="symbol">std:</span><span class="symbol">:vector&lt;std</span><span class="symbol">:</span><span class="symbol">:string&gt;</span> v;
<span class="symbol">std:</span><span class="symbol">:transform</span>(v.<span class="keyword">begin</span>(), v.<span class="keyword">end</span>(), v.<span class="keyword">begin</span>(),
    <span class="symbol">std:</span><span class="symbol">:bind1st</span>(<span class="symbol">std:</span><span class="symbol">:plus&lt;std</span><span class="symbol">:</span><span class="symbol">:string&gt;</span>(), <span class="string">";"</span>));
<span class="regexp">//</span> <span class="string">"x"</span> -&gt; <span class="string">";x"</span>

<span class="symbol">std:</span><span class="symbol">:transform</span>(v.<span class="keyword">begin</span>(), v.<span class="keyword">end</span>(), v.<span class="keyword">begin</span>(),
    <span class="symbol">std:</span><span class="symbol">:bind2st</span>(<span class="symbol">std:</span><span class="symbol">:plus&lt;std</span><span class="symbol">:</span><span class="symbol">:string&gt;</span>(), <span class="string">";"</span>));
<span class="regexp">//</span> <span class="string">"x"</span> -&gt; <span class="string">"x;"</span>
</code></pre><p>+++<br>+++ slide</p>
<h3 id="C++11"><code>C++</code>11</h3>
<p>+++<br>+++ slide</p>
<h3 id="std::mem_fn"><code>std::mem_fn</code></h3>
<p>Generalized version of <code>std::mem_fun</code>.</p>
<ul>
<li>handles arbitrary number of arguments</li>
<li>the object can be passed by reference, plain or smart pointer.</li>
</ul>
<p>+++<br>+++ slide</p>
<pre><code>typedef <span class="symbol">std:</span><span class="symbol">:vector&lt;std</span><span class="symbol">:</span><span class="symbol">:shared_ptr&lt;Players&gt;&gt;</span> <span class="constant">Players;</span>
void <span class="constant">Transform(Players&amp;</span> players, const <span class="constant">Transform&amp;</span> t)
{
    <span class="symbol">std:</span><span class="symbol">:for_each</span>(players.<span class="keyword">begin</span>(), players.<span class="keyword">end</span>(),
                  <span class="symbol">std:</span><span class="symbol">:mem_fn</span>(&amp;<span class="constant">Player:</span><span class="symbol">:TransformWith</span>));
}
</code></pre><h1 id="+++-1">+++</h1>
<p>=== topic<br>+++ slide</p>
<h1 id="std::bind"><code>std::bind</code></h1>
<p>+++<br>+++ slide</p>
<h1 id="std::bind-1"><code>std::bind</code></h1>
<ul>
<li>binding any argument of a function to a fixed value</li>
<li>reordering of arguments</li>
</ul>
<p>+++<br>+++ slide</p>
<h1 id="std::bind-1"><code>std::bind</code></h1>
<ul>
<li>former <code>boost::bind</code> - <code>boost</code> version is still <em>boosted</em> with extra features</li>
</ul>
<p>+++<br>+++ slide</p>
<pre><code><span class="keyword">template</span> &lt;typename <span class="type">Callback</span>&gt;
std::shared_ptr&lt;<span class="type">Button</span>&gt; make_button(<span class="type">Callback</span> callback);

struct <span class="type">Application</span> {
    <span class="type">void</span> <span class="type">Quit</span>();
};

<span class="type">Application</span> app;
<span class="type">auto</span> quit = make_button(std::<span class="keyword">bind</span>(&amp;<span class="type">Application</span>::<span class="type">Quit</span>, &amp;app));
</code></pre><p>+++<br>+++ slide</p>
<p>Be sure that the <em>quit</em> button will not be clicked after <code>app</code> is destroyed.</p>
<p>+++<br>+++ slide</p>
<pre><code><span class="symbol">std:</span><span class="symbol">:shared_ptr&lt;Application&gt;</span> app;
auto quit = make_button(<span class="symbol">std:</span><span class="symbol">:bind</span>(&amp;<span class="constant">Application:</span><span class="symbol">:Quit</span>, app));
</code></pre><p>+++<br>+++ slide</p>
<h2 id="Arguments">Arguments</h2>
<pre><code><span class="keyword">auto</span> autosave = make_checkbox(std::bind(&amp;Application::Autosave, app,
                                        std::placeholders::_1));
</code></pre><p>+++<br>+++ slide</p>
<p><code>C#</code> delegates in C++.</p>
<p>+++<br>+++ slide</p>
<pre><code><span class="keyword">void</span> Function(std::<span class="built_in">string</span> s, <span class="keyword">int</span> n, Person p) {
    std::<span class="built_in">cout</span> &lt;&lt; p.name() &lt;&lt; <span class="string">": "</span> &lt;&lt; s;
    <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>)
        std::<span class="built_in">cout</span> &lt;&lt; <span class="string">'!'</span>;
    std::<span class="built_in">cout</span> &lt;&lt; std::endl;
}

Person p(<span class="string">"Yoda"</span>);
<span class="keyword">auto</span> mega_fun = std::bind(&amp;Function, _2, _1, &amp;p);

mega_fun(<span class="number">3</span>, <span class="string">"The Answer is 42"</span>);
<span class="comment">// Yoda: The answer is 42!!!</span>
</code></pre><h1 id="+++-2">+++</h1>
<p>=== topic</p>
<p>+++ slide</p>
<h1 id="std::function"><code>std::function</code></h1>
<p>+++<br>+++ slide</p>
<p><code>std::function</code> is a generic function object.</p>
<p>+++<br>+++ slide</p>
<h2 id="Functions_in_C++-1">Functions in C++</h2>
<p>Let me count the ways …</p>
<p>+++<br>+++ slide</p>
<h3 id="Free_functions">Free functions</h3>
<p>::: snippet 10_functional/functions.cxx free<br>:::</p>
<p>+++<br>+++ slide</p>
<h3 id="Functors">Functors</h3>
<p>::: snippet 10_functional/functions.cxx functor<br>:::</p>
<p>+++<br>+++ slide</p>
<h3 id="Methods">Methods</h3>
<p>::: snippet 10_functional/functions.cxx method<br>:::</p>
<p>+++<br>+++ slide</p>
<h3 id="Pointer_to_functions">Pointer to functions</h3>
<p>::: snippet 10_functional/functions.cxx pointer<br>:::</p>
<p>+++<br>+++ slide</p>
<h3 id="std::function-1"><code>std::function</code></h3>
<p>::: snippet 10_functional/functions.cxx function<br>:::</p>
<p>+++<br>+++ slide</p>
<h3 id="std::function_with_types"><code>std::function</code> with types</h3>
<p>::: snippet 10_functional/functions.cxx function-ud<br>:::</p>
<p>+++<br>+++ slide</p>
<h3 id="std::function_std::bind"><code>std::function std::bind</code></h3>
<p>::: snippet 10_functional/functions.cxx bind<br>:::</p>
<h1 id="+++-3">+++</h1>
<p>=== topic<br>+++ slide</p>
<h1 id="Functions_and_tuples">Functions and tuples</h1>
<h1 id="+++-4">+++</h1>
<p>=== topic<br>+++ slide</p>
<h1 id="Functions_in_C++11">Functions in <code>C++11</code></h1>
<p>+++</p>
<p>+++ slide<br>    template <typename t=""><br>    T plus(T lhs, T rhs) {<br>        return lhs + rhs;<br>    }<br>+++<br>+++ slide</typename></p>
<pre><code><span class="attribute">auto s </span>=<span class="string"> plus(2, 2);</span>
</code></pre><p>+++<br>+++ slide</p>
<pre><code><span class="title">Person</span> p1;
<span class="title">Person</span> p2;
<span class="title">auto</span> s = plus(p1, p2)
</code></pre><p>+++<br>+++ slide<br>    struct Person<br>    {<br>        Household operator+(const Person&amp;);<br>    }<br>+++<br>+++ slide<br>    ??? plus(Person lhs, Person rhs) {<br>        return lhs + rhs;<br>    }<br>+++<br>+++ slide</p>
<pre><code><span class="input"><span class="prompt">auto plus(Person lhs, Person rhs) -&gt;</span> decltype(lhs + rhs)</span>
{
    <span class="keyword">return</span> lhs + rhs;
}
</code></pre><h1 id="+++-5">+++</h1>
<p>=== topic<br>+++ slide</p>
<h1 id="Functions_in_C++14">Functions in <code>C++14</code></h1>
<p>+++</p>
<p>+++ slide<br>    ??? plus(Person lhs, Person rhs)<br>    {<br>        return lhs + rhs;<br>    }<br>+++<br>+++ slide</p>
<pre><code><span class="type">auto</span> plus(<span class="type">Person</span> lhs, <span class="type">Person</span> rhs)
{
    <span class="keyword">return</span> lhs + rhs;
}
</code></pre><p>+++<br>+++ slide</p>
<ul>
<li>all returns must have the same type<ul>
<li>single return</li>
</ul>
</li>
</ul>
<h1 id="+++-6">+++</h1>
</article></section></div><div class="col-sm-3"><nav role="navigation" class="navbar navbar-default"><div class="navbar-header"><div class="navbar-brand">Recent Posts</div></div><div class="clearfix"></div><ul class="nav navbar-stacked"><li><a href="/advanced-cpp/2015/04/14/locking-problem/">Locking problem</a></li><li><a href="/advanced-cpp/2015/04/03/functional/">Functional C++</a></li><li><a href="/advanced-cpp/2015/03/27/error-handling/">Error Handling</a></li><li><a href="/advanced-cpp/2015/03/20/namespaces/">Namespaces</a></li><li><a href="/advanced-cpp/2015/03/20/libraries/">Libraries</a></li><li><a href="/advanced-cpp/2015/03/15/smart-pointers/">Smart Pointers</a></li><li><a href="/advanced-cpp/2015/03/06/practice/">The practice of C++</a></li><li><a href="/advanced-cpp/2015/03/06/overview/">Overview of C++</a></li></ul></nav></div></div><footer id="page-footer"><footer><div class="row-fluid"><div class="col-md-12"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" width="88px" height="31px" src="/advanced-cpp/images/cc-by-sa.png"></a><br><span>Advanced C++</span> by<span> SofiaC++</span> is licensed under a&nbsp;<a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International
License
</a></div></div></footer><script src="/advanced-cpp/bower_components/jquery/dist/jquery.min.js"></script><script src="/advanced-cpp/bower_components/bootstrap/dist/js/bootstrap.min.js"></script></footer></div></body></html>